# トピック5

## 課題：都市の人口の流出入シミュレーション（その１）

前回に引き続き，オブジェクト指向の考え方を理解してもらうために，ひとつの都市をオブジェクトとして，都市間の人口の流出入のシミュレーションを行うプログラムを作成する．前回のCityクラス，CityMainクラスと似ているが，よりオブジェクト指向的な利用法を学んでもらう．

### 都市間の人口の入出力のモデル（このプログラムでの）

都市には，人口のほかに，その都市の「魅力度（整数）」があると仮定する．ある都市Aから別な都市Bに，1年間に流出する人数は，都市Bの魅力度に比例するものとする．つまりBの都市が魅力的である度合いが高ければ，その都市により多くの人口が流入し，その分だけAの都市から人口が減るものと考える．逆にBからもAの魅力度に応じて，人口がAに流入し，Bからはその分だけ人口が減る．

このような行き来が何年も続くと，都市の人口は最終的にどのようになるのだろうか．１つの都市だけが最も多くなり，他の都市は人口が０になってしまうのか，それともすべての都市が同じ人口に落ち着くのか，または全く違った人口に落ち着くのだろうか．これをコンピュータシミュレーションするプログラムを作成したい．

そこで，次のような設定を考える

１．一つの都市には，その人口(p: int型)，魅力度(attract: int型)が保存されている．
２．都市から，その人口の1％に，相手の都市の魅力度をかける．その人数を，相手の都市の人口に加え，自分の都市の人口から引く．以下の図はAからBへ流入する場合と，BからAに流入する場合の2つを示している．

これをプログラムとして実現するために，一つの都市をオブジェクトとした次のような設計を行う．

## プログラムの設計

### １．各都市の人口と魅力度を記憶し，人口の流入，流出を処理する City クラスを次のように設計する．

1-1) 前の演習と同様に，ipp1プロジェクトの下に，city という名前のパッケージを作成する（先頭小文字）.

1-2) cityパッケージの下に，City というクラスを作成する（先頭大文字）．（以前の演習で説明したように，先頭部分に，@authorで初めて，bで始まる学生番号と，半角空白で区切って，自分の氏名を記入したコメントを入れるのを忘れないこと）

1-3) City クラスに，以下の2つのインスタンス変数を作る
```
p：int型，その都市の人口を保持する
```
```
attract: int型，その都市の魅力度を保持する
```
1-4) City クラスに，その都市の人口と魅力度を初期設定するコンストラクタを作る

コンストラクタは引数を2つもち，1番目の引数は人口（インスタンス変数p)に初期値を与え，2番目の引数は魅力度（インスタンス変数attract）の初期値を与えるものとする．

1-5) City クラスに，以下のpublicメソッドを作成する
```
getP(): 返し値はint型．人口（p）のゲッター．
```
```
getAttract(): 返し値はint型．魅力度（attract）のゲッター
```
```
addP(int n): void型(返し値なし）．引数nだけ，人口（p）を増やす
```
```
delP(int n): int型，人口(p)に0.01とnをかけた結果をint値として計算し（たとえばmという作業用変数に代入しておく），その値mを人口から差し引き，返し値としてmを返す．
※ 上記のmに代入する値を計算した結果はdoubleになるので，(int)を付けてキャストしてint型の値を得てから代入すること．
```
２．シミュレーションの計算を行うクラスを作成する（その１）

シミュレーションの計算を行うクラスを，CityMainという名前で作成する．具体的には，

2-1) cityパッケージの下に，CityMain というクラスを作成する（先頭大文字）．

2-2) CityMainに，以下のように，３つのCityクラスのインスタンスを作成して，その人口を出力するサンプルプログラムを作成する．学生番号と氏名の記入を忘れないように．

```java
package city;
/**
 *
 * @author b学生番号 氏名
 *
 */
public class CityMain {

    private City hkd, ask, spr;

    CityMain () {
        hkd = new City(200000, 3);
        ask = new City(400000, 1);
        +   " S:" + spr.getP();
        spr = new City(1800000, 2);
    }

    public String calc () {
        return
                " H:" + hkd.getP()
            +   " A:" + ask.getP()
    }

    public static v
    oid main(String[] args) {
        CityMain m = new CityMain();
        System.out.println　(m.calc());
    }
}
```

このプログラムでは，hkd市，ask市，spr市の3つの市を定義し，それぞれの人口と魅力度をコンストラクタで初期化している．

## プログラムの提出

とりあえずここまでの段階で，CityMainを実行して，
```
H:200000 A:400000 S:1800000
```
という出力が得られていることを確認し，cityパッケージをcity1.jarというファイルにエクスポートし，以下にアップロードして提出すること．

次の課題では，CityMainのプログラムを書き直して，当初の複数の都市間の人口流出入のシミュレーションを完成させる．

##  都市の人口流出入シュミレーション(その2)   

### CityMainを書き換え，3都市流出入シミュレーションを完成させる

CityMainのcalcは，以下のような都市の人口を文字列として返すだけのメソッドだった．
```
H:200000 A:400000 S:1800000
```
そこで，calcの先頭部分に，3都市の流出入を計算する行を追加し，mainを書き換えて，calcを200回実行（200年後までのシミュレーションを実行）するようにしたい．

### 手順１

具体的には，
```
hkd市に，spr市から人口が加わり，その分だけspr市から人口が削除される．
hkd市に，ask市から人口が加わり，その分だけask市から人口が削除される．
spr市に，hkd市から人口が加わり，その分だけhkd市から人口が削除される．
spr市に，ask市から人口が加わり，その分だけask市から人口が削除される．
ask市に，hkd市から人口が加わり，その分だけhkd市から人口が削除される．
ask市に，spr市から人口が加わり，その分だけspr市から人口が削除される．
```
という行を追加することで行われる．

1行目の具体的な考え方を例として示す：

たとえばCityのインスタンスであるhkdは，addPというメソッドを呼ぶことで，その引数分の人口を加算することができる．

同様に，Cityのインスタンスであるsprは，delPというメソッドを呼ぶと，その引数倍の人口をsprから削除して，削除した人口の値を返す．

delPの引数は，流出先の都市の魅力度になる．魅力度はgetAttractメソッドで得ることができるので，この場合はhkdのgetAttractメソッドを呼べばよい．

これらを組み合わせることで，1行目の処理は，簡単な1行のプログラムで収まる．
### 手順２

main部分は，その１ではSystem.out.println( m.calc() );を1度呼ぶだけだった．そこで，この行を200回繰り返すように書き換えなさい．
